#!/usr/bin/env python3
"""
DevStream Session Summary Generator - Context7 Compliant

Aggregates triple-source session data into unified markdown summaries.
Follows DevStream summary format with work accomplished, decisions, and learnings.

Architecture:
- Input: SessionData + MemoryStats + TaskStats (from SessionDataExtractor)
- Output: Markdown-formatted session summary
- Storage: Summary stored in semantic_memory with embedding

Context7 Patterns:
- Structured data aggregation with dataclasses
- Template-based markdown generation
- Clear separation of concerns (extract ‚Üí aggregate ‚Üí generate)
"""

import sys
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass

# Add utils to path
sys.path.append(str(Path(__file__).parent.parent / 'utils'))
from logger import get_devstream_logger

# Import data structures from extractor
sys.path.append(str(Path(__file__).parent))
from session_data_extractor import SessionData, MemoryStats, TaskStats


@dataclass
class SessionSummary:
    """
    Unified session summary structure.

    Aggregates data from all three sources into a single coherent summary.
    """
    session_id: str
    session_name: Optional[str]
    started_at: datetime
    ended_at: datetime
    duration_minutes: int
    duration_formatted: str  # Human-readable duration (e.g., "2 hours 15 minutes", "45 seconds")

    # Work accomplished
    tasks_completed: int
    tasks_active: int
    files_modified: int
    tokens_used: int

    # Key outputs
    completed_task_titles: List[str]
    modified_files: List[str]

    # Decisions and learnings
    key_decisions: List[str]
    lessons_learned: List[str]

    # Status
    status: str

    def to_markdown(self) -> str:
        """
        Generate markdown-formatted session summary.

        Returns:
            Markdown string with structured summary
        """
        # Format timestamps
        started = self.started_at.strftime("%Y-%m-%d %H:%M:%S")
        ended = self.ended_at.strftime("%Y-%m-%d %H:%M:%S")

        # Build summary sections
        md = f"""# DevStream Session Summary

**Session**: {self.session_name or self.session_id}
**Started**: {started}
**Ended**: {ended}
**Duration**: {self.duration_formatted}
**Status**: {self.status}

---

## üìä Work Accomplished

### Tasks Completed: {self.tasks_completed}
"""

        # Add completed task titles
        if self.completed_task_titles:
            md += "\n"
            for title in self.completed_task_titles[:10]:  # Top 10
                md += f"- {title}\n"
            if len(self.completed_task_titles) > 10:
                md += f"- _(+{len(self.completed_task_titles) - 10} more tasks)_\n"
        else:
            md += "\n_No tasks completed this session_\n"

        # Add active tasks
        if self.tasks_active > 0:
            md += f"\n### Active Tasks: {self.tasks_active}\n"
            md += "\n_Tasks in progress at session end_\n"

        # Add files modified
        md += f"\n### Files Modified: {self.files_modified}\n"

        if self.modified_files:
            md += "\n"
            for file_path in self.modified_files[:10]:  # Top 10
                md += f"- `{file_path}`\n"
            if len(self.modified_files) > 10:
                md += f"- _(+{len(self.modified_files) - 10} more files)_\n"
        else:
            md += "\n_No files modified this session_\n"

        # Add token usage
        md += f"\n### Resources Used\n\n"
        md += f"- **Tokens**: {self.tokens_used:,}\n"

        # Add key decisions
        md += "\n---\n\n## üéØ Key Decisions\n\n"

        if self.key_decisions:
            for i, decision in enumerate(self.key_decisions[:5], 1):  # Top 5
                md += f"{i}. {decision}\n\n"
            if len(self.key_decisions) > 5:
                md += f"_(+{len(self.key_decisions) - 5} more decisions recorded)_\n\n"
        else:
            md += "_No major decisions recorded this session_\n\n"

        # Add lessons learned
        md += "---\n\n## üí° Lessons Learned\n\n"

        if self.lessons_learned:
            for i, lesson in enumerate(self.lessons_learned[:5], 1):  # Top 5
                md += f"{i}. {lesson}\n\n"
            if len(self.lessons_learned) > 5:
                md += f"_(+{len(self.lessons_learned) - 5} more learnings captured)_\n\n"
        else:
            md += "_No lessons learned recorded this session_\n\n"

        # Footer
        md += "---\n\n"
        md += f"_Generated by DevStream SessionEnd hook on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}_\n"

        return md


class SessionSummaryGenerator:
    """
    Generate session summaries from triple-source data.

    Aggregates SessionData, MemoryStats, and TaskStats into unified
    SessionSummary with markdown output.

    Context7 Pattern: Clear separation of extraction ‚Üí aggregation ‚Üí generation
    """

    def __init__(self):
        """Initialize SessionSummaryGenerator."""
        self.structured_logger = get_devstream_logger('session_summary_generator')
        self.logger = self.structured_logger.logger

        self.logger.info("SessionSummaryGenerator initialized")

    def _format_duration(self, started_at: datetime, ended_at: datetime) -> str:
        """
        Format session duration in human-readable format.

        Handles short sessions (<1 minute) by showing seconds instead of "0 minutes".

        Args:
            started_at: Session start timestamp
            ended_at: Session end timestamp

        Returns:
            Human-readable duration string (e.g., "2 hours 15 minutes", "45 seconds", "1 second")

        Examples:
            >>> _format_duration(datetime(2025, 1, 1, 10, 0, 0), datetime(2025, 1, 1, 10, 0, 30))
            "30 seconds"
            >>> _format_duration(datetime(2025, 1, 1, 10, 0, 0), datetime(2025, 1, 1, 10, 5, 0))
            "5 minutes"
            >>> _format_duration(datetime(2025, 1, 1, 10, 0, 0), datetime(2025, 1, 1, 12, 15, 0))
            "2 hours 15 minutes"
        """
        if not ended_at or not started_at:
            return "0 minutes"

        duration_seconds = int((ended_at - started_at).total_seconds())

        # Less than 1 minute ‚Üí show seconds
        if duration_seconds < 60:
            return f"{duration_seconds} second{'s' if duration_seconds != 1 else ''}"

        # Less than 1 hour ‚Üí show minutes
        elif duration_seconds < 3600:
            minutes = duration_seconds // 60
            return f"{minutes} minute{'s' if minutes != 1 else ''}"

        # 1 hour or more ‚Üí show hours + minutes
        else:
            hours = duration_seconds // 3600
            minutes = (duration_seconds % 3600) // 60
            parts = []
            parts.append(f"{hours} hour{'s' if hours != 1 else ''}")
            if minutes > 0:
                parts.append(f"{minutes} minute{'s' if minutes != 1 else ''}")
            return " ".join(parts)

    def aggregate_session_data(
        self,
        session_data: SessionData,
        memory_stats: MemoryStats,
        task_stats: TaskStats
    ) -> SessionSummary:
        """
        Aggregate triple-source data into unified summary.

        Combines data from work_sessions, semantic_memory, and micro_tasks
        into a single SessionSummary structure.

        Args:
            session_data: Session metadata from work_sessions
            memory_stats: Memory statistics from semantic_memory
            task_stats: Task statistics from micro_tasks

        Returns:
            SessionSummary with aggregated data

        Raises:
            ValueError: If required data is missing
        """
        if not session_data:
            raise ValueError("session_data is required")

        if not session_data.started_at:
            raise ValueError("session_data.started_at is required")

        # Calculate session end time
        ended_at = session_data.ended_at or datetime.now()

        # Calculate duration
        duration = ended_at - session_data.started_at
        duration_minutes = int(duration.total_seconds() / 60)

        # Format duration for human readability (handles short sessions)
        duration_formatted = self._format_duration(session_data.started_at, ended_at)

        self.logger.debug(
            "Aggregating session data",
            session_id=session_data.session_id,
            duration_minutes=duration_minutes,
            duration_formatted=duration_formatted,
            tasks_completed=task_stats.completed if task_stats else 0,
            files_modified=memory_stats.files_modified if memory_stats else 0
        )

        # Build summary
        summary = SessionSummary(
            session_id=session_data.session_id,
            session_name=session_data.session_name,
            started_at=session_data.started_at,
            ended_at=ended_at,
            duration_minutes=duration_minutes,
            duration_formatted=duration_formatted,

            # Work accomplished
            tasks_completed=task_stats.completed if task_stats else 0,
            tasks_active=task_stats.active if task_stats else 0,
            files_modified=memory_stats.files_modified if memory_stats else 0,
            tokens_used=session_data.tokens_used,

            # Key outputs
            completed_task_titles=task_stats.task_titles if task_stats else [],
            modified_files=memory_stats.file_list if memory_stats else [],

            # Decisions and learnings
            key_decisions=memory_stats.decisions if memory_stats else [],
            lessons_learned=memory_stats.learnings if memory_stats else [],

            # Status
            status=session_data.status
        )

        self.logger.info(
            "Session data aggregated",
            session_id=session_data.session_id,
            duration_minutes=duration_minutes,
            tasks_completed=summary.tasks_completed,
            files_modified=summary.files_modified
        )

        return summary

    def generate_summary(
        self,
        session_data: SessionData,
        memory_stats: MemoryStats,
        task_stats: TaskStats
    ) -> str:
        """
        Generate markdown session summary from triple-source data.

        High-level convenience method that aggregates and generates markdown.

        Args:
            session_data: Session metadata from work_sessions
            memory_stats: Memory statistics from semantic_memory
            task_stats: Task statistics from micro_tasks

        Returns:
            Markdown-formatted session summary

        Raises:
            ValueError: If required data is missing
        """
        try:
            # Aggregate data
            summary = self.aggregate_session_data(
                session_data,
                memory_stats,
                task_stats
            )

            # Generate markdown
            markdown = summary.to_markdown()

            self.logger.info(
                "Session summary generated",
                session_id=session_data.session_id,
                markdown_length=len(markdown)
            )

            return markdown

        except Exception as e:
            self.logger.error(
                "Failed to generate session summary",
                error=str(e),
                error_type=type(e).__name__
            )
            raise

    def validate_summary(self, summary: SessionSummary) -> bool:
        """
        Validate session summary for completeness.

        Checks that summary has all required fields and reasonable values.

        Args:
            summary: SessionSummary to validate

        Returns:
            True if valid, False otherwise
        """
        try:
            # Check required fields
            if not summary.session_id:
                self.logger.warning("Missing session_id")
                return False

            if not summary.started_at or not summary.ended_at:
                self.logger.warning("Missing timestamps")
                return False

            # Check duration is reasonable
            if summary.duration_minutes < 0:
                self.logger.warning(
                    "Negative duration",
                    duration=summary.duration_minutes
                )
                return False

            # Check that end time is after start time
            if summary.ended_at < summary.started_at:
                self.logger.warning("End time before start time")
                return False

            self.logger.debug(
                "Summary validation passed",
                session_id=summary.session_id
            )

            return True

        except Exception as e:
            self.logger.error(
                "Summary validation error",
                error=str(e)
            )
            return False


def format_session_for_storage(summary: SessionSummary) -> Dict[str, Any]:
    """
    Format SessionSummary for storage in semantic_memory.

    Prepares summary data for storage with appropriate content_type
    and keywords for later retrieval.

    Args:
        summary: SessionSummary to format

    Returns:
        Dict with content, content_type, and keywords
    """
    return {
        "content": summary.to_markdown(),
        "content_type": "context",  # Session summaries are contextual information
        "keywords": [
            "session",
            "summary",
            summary.session_id,
            f"{summary.tasks_completed}_tasks",
            f"{summary.files_modified}_files",
            summary.status
        ]
    }


if __name__ == "__main__":
    # Test script
    from datetime import timedelta

    print("DevStream Session Summary Generator Test")
    print("=" * 50)

    # Create test data
    print("\n1. Creating test session data...")
    session_data = SessionData(
        session_id="test-session-001",
        session_name="Phase 3 Implementation",
        started_at=datetime.now() - timedelta(hours=2),
        ended_at=datetime.now(),
        tokens_used=15000,
        active_tasks=["DEVSTREAM-001", "DEVSTREAM-002"],
        completed_tasks=["DEVSTREAM-003"],
        status="completed"
    )
    print(f"   Session: {session_data.session_name}")

    print("\n2. Creating test memory stats...")
    memory_stats = MemoryStats(
        files_modified=5,
        decisions_made=2,
        learnings_captured=3,
        total_records=50,
        file_list=[
            "session_data_extractor.py",
            "session_summary_generator.py",
            "session_end.py"
        ],
        decisions=[
            "Use triple-source architecture for accuracy",
            "Implement Context7 async patterns for performance"
        ],
        learnings=[
            "aiosqlite row_factory enables clean data access",
            "Time-range queries essential for session-scoped data",
            "Graceful degradation critical for production reliability"
        ]
    )
    print(f"   Files modified: {memory_stats.files_modified}")
    print(f"   Decisions: {memory_stats.decisions_made}")

    print("\n3. Creating test task stats...")
    task_stats = TaskStats(
        total_tasks=10,
        completed=7,
        active=2,
        failed=0,
        task_titles=[
            "Implement SessionDataExtractor",
            "Create SessionSummaryGenerator",
            "Integrate WorkSessionManager"
        ]
    )
    print(f"   Completed: {task_stats.completed}/{task_stats.total_tasks}")

    print("\n4. Generating session summary...")
    generator = SessionSummaryGenerator()

    try:
        summary = generator.aggregate_session_data(
            session_data,
            memory_stats,
            task_stats
        )
        print(f"   ‚úÖ Summary aggregated")
        print(f"   Duration: {summary.duration_minutes} minutes")
        print(f"   Tasks: {summary.tasks_completed} completed")

        # Validate
        print("\n5. Validating summary...")
        if generator.validate_summary(summary):
            print("   ‚úÖ Validation passed")
        else:
            print("   ‚ùå Validation failed")

        # Generate markdown
        print("\n6. Generating markdown...")
        markdown = summary.to_markdown()
        print(f"   ‚úÖ Markdown generated: {len(markdown)} chars")

        # Show preview
        print("\n7. Markdown preview:")
        print("-" * 50)
        print(markdown[:800])  # First 800 chars
        print("...")
        print("-" * 50)

        # Format for storage
        print("\n8. Formatting for storage...")
        storage_data = format_session_for_storage(summary)
        print(f"   Content type: {storage_data['content_type']}")
        print(f"   Keywords: {', '.join(storage_data['keywords'][:5])}")

        print("\n" + "=" * 50)
        print("Test completed successfully!")

    except Exception as e:
        print(f"\n‚ùå Test failed: {e}")
        import traceback
        traceback.print_exc()