#!/usr/bin/env python3
"""
DevStream Session Summary Generator - Context7 Compliant

Aggregates triple-source session data into unified markdown summaries.
Follows DevStream summary format with work accomplished, decisions, and learnings.

Architecture:
- Input: SessionData + MemoryStats + TaskStats (from SessionDataExtractor)
- Output: Markdown-formatted session summary
- Storage: Summary stored in semantic_memory with embedding

Context7 Patterns:
- Structured data aggregation with dataclasses
- Template-based markdown generation
- Clear separation of concerns (extract → aggregate → generate)
"""

import sys
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass

# Add utils to path
sys.path.append(str(Path(__file__).parent.parent / 'utils'))
from logger import get_devstream_logger

# Import data structures from extractor
sys.path.append(str(Path(__file__).parent))
from session_data_extractor import SessionData, MemoryStats, TaskStats


@dataclass
class SessionSummary:
    """
    Unified session summary structure.

    Aggregates data from all three sources into a single coherent summary.
    """
    session_id: str
    session_name: Optional[str]
    started_at: datetime
    ended_at: datetime
    duration_minutes: int
    duration_formatted: str  # Human-readable duration (e.g., "2 hours 15 minutes", "45 seconds")

    # Work accomplished
    tasks_completed: int
    tasks_active: int
    files_modified: int
    tokens_used: int

    # Key outputs
    completed_task_titles: List[str]
    modified_files: List[str]

    # Decisions and learnings
    key_decisions: List[str]
    lessons_learned: List[str]

    # Status
    status: str

    def to_markdown(self) -> str:
        """
        Generate markdown-formatted session summary.

        Returns:
            Markdown string with structured summary
        """
        # Format timestamps
        started = self.started_at.strftime("%Y-%m-%d %H:%M:%S")
        ended = self.ended_at.strftime("%Y-%m-%d %H:%M:%S")

        # Build summary sections
        md = f"""# DevStream Session Summary

**Session**: {self.session_name or self.session_id}
**Started**: {started}
**Ended**: {ended}
**Duration**: {self.duration_formatted}
**Status**: {self.status}

---

## 📊 Work Accomplished

### Tasks Completed: {self.tasks_completed}
"""

        # Add completed task titles
        if self.completed_task_titles:
            md += "\n"
            for title in self.completed_task_titles[:10]:  # Top 10
                md += f"- {title}\n"
            if len(self.completed_task_titles) > 10:
                md += f"- _(+{len(self.completed_task_titles) - 10} more tasks)_\n"
        else:
            md += "\n_No tasks completed this session_\n"

        # Add active tasks
        if self.tasks_active > 0:
            md += f"\n### Active Tasks: {self.tasks_active}\n"
            md += "\n_Tasks in progress at session end_\n"

        # Add files modified
        md += f"\n### Files Modified: {self.files_modified}\n"

        if self.modified_files:
            md += "\n"
            for file_path in self.modified_files[:10]:  # Top 10
                md += f"- `{file_path}`\n"
            if len(self.modified_files) > 10:
                md += f"- _(+{len(self.modified_files) - 10} more files)_\n"
        else:
            md += "\n_No files modified this session_\n"

        # Add token usage
        md += f"\n### Resources Used\n\n"
        md += f"- **Tokens**: {self.tokens_used:,}\n"

        # Add key decisions
        md += "\n---\n\n## 🎯 Key Decisions\n\n"

        if self.key_decisions:
            for i, decision in enumerate(self.key_decisions[:5], 1):  # Top 5
                md += f"{i}. {decision}\n\n"
            if len(self.key_decisions) > 5:
                md += f"_(+{len(self.key_decisions) - 5} more decisions recorded)_\n\n"
        else:
            md += "_No major decisions recorded this session_\n\n"

        # Add lessons learned
        md += "---\n\n## 💡 Lessons Learned\n\n"

        if self.lessons_learned:
            for i, lesson in enumerate(self.lessons_learned[:5], 1):  # Top 5
                md += f"{i}. {lesson}\n\n"
            if len(self.lessons_learned) > 5:
                md += f"_(+{len(self.lessons_learned) - 5} more learnings captured)_\n\n"
        else:
            md += "_No lessons learned recorded this session_\n\n"

        # Footer
        md += "---\n\n"
        md += f"_Generated by DevStream SessionEnd hook on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}_\n"

        return md


class SessionSummaryGenerator:
    """
    Generate session summaries from triple-source data.

    Aggregates SessionData, MemoryStats, and TaskStats into unified
    SessionSummary with markdown output.

    Context7 Pattern: Clear separation of extraction → aggregation → generation
    """

    def __init__(self):
        """Initialize SessionSummaryGenerator."""
        self.structured_logger = get_devstream_logger('session_summary_generator')
        self.logger = self.structured_logger.logger

        self.logger.info("SessionSummaryGenerator initialized")

    def _format_duration(self, started_at: datetime, ended_at: datetime) -> str:
        """
        Format session duration in human-readable format.

        Handles short sessions (<1 minute) by showing seconds instead of "0 minutes".

        Args:
            started_at: Session start timestamp
            ended_at: Session end timestamp

        Returns:
            Human-readable duration string (e.g., "2 hours 15 minutes", "45 seconds", "1 second")

        Examples:
            >>> _format_duration(datetime(2025, 1, 1, 10, 0, 0), datetime(2025, 1, 1, 10, 0, 30))
            "30 seconds"
            >>> _format_duration(datetime(2025, 1, 1, 10, 0, 0), datetime(2025, 1, 1, 10, 5, 0))
            "5 minutes"
            >>> _format_duration(datetime(2025, 1, 1, 10, 0, 0), datetime(2025, 1, 1, 12, 15, 0))
            "2 hours 15 minutes"
        """
        if not ended_at or not started_at:
            return "0 minutes"

        duration_seconds = int((ended_at - started_at).total_seconds())

        # Less than 1 minute → show seconds
        if duration_seconds < 60:
            return f"{duration_seconds} second{'s' if duration_seconds != 1 else ''}"

        # Less than 1 hour → show minutes
        elif duration_seconds < 3600:
            minutes = duration_seconds // 60
            return f"{minutes} minute{'s' if minutes != 1 else ''}"

        # 1 hour or more → show hours + minutes
        else:
            hours = duration_seconds // 3600
            minutes = (duration_seconds % 3600) // 60
            parts = []
            parts.append(f"{hours} hour{'s' if hours != 1 else ''}")
            if minutes > 0:
                parts.append(f"{minutes} minute{'s' if minutes != 1 else ''}")
            return " ".join(parts)

    def aggregate_session_data(
        self,
        session_data: SessionData,
        memory_stats: MemoryStats,
        task_stats: TaskStats
    ) -> SessionSummary:
        """
        Aggregate triple-source data into unified summary.

        Combines data from work_sessions, semantic_memory, and micro_tasks
        into a single SessionSummary structure.

        Args:
            session_data: Session metadata from work_sessions
            memory_stats: Memory statistics from semantic_memory
            task_stats: Task statistics from micro_tasks

        Returns:
            SessionSummary with aggregated data

        Raises:
            ValueError: If required data is missing
        """
        if not session_data:
            raise ValueError("session_data is required")

        if not session_data.started_at:
            raise ValueError("session_data.started_at is required")

        # Calculate session end time
        ended_at = session_data.ended_at or datetime.now()

        # Calculate duration
        duration = ended_at - session_data.started_at
        duration_minutes = int(duration.total_seconds() / 60)

        # Format duration for human readability (handles short sessions)
        duration_formatted = self._format_duration(session_data.started_at, ended_at)

        self.logger.debug(
            "Aggregating session data",
            session_id=session_data.session_id,
            duration_minutes=duration_minutes,
            duration_formatted=duration_formatted,
            tasks_completed=task_stats.completed if task_stats else 0,
            files_modified=memory_stats.files_modified if memory_stats else 0
        )

        # Build summary
        summary = SessionSummary(
            session_id=session_data.session_id,
            session_name=session_data.session_name,
            started_at=session_data.started_at,
            ended_at=ended_at,
            duration_minutes=duration_minutes,
            duration_formatted=duration_formatted,

            # Work accomplished
            tasks_completed=task_stats.completed if task_stats else 0,
            tasks_active=task_stats.active if task_stats else 0,
            files_modified=memory_stats.files_modified if memory_stats else 0,
            tokens_used=session_data.tokens_used,

            # Key outputs
            completed_task_titles=task_stats.task_titles if task_stats else [],
            modified_files=memory_stats.file_list if memory_stats else [],

            # Decisions and learnings
            key_decisions=memory_stats.decisions if memory_stats else [],
            lessons_learned=memory_stats.learnings if memory_stats else [],

            # Status
            status=session_data.status
        )

        self.logger.info(
            "Session data aggregated",
            session_id=session_data.session_id,
            duration_minutes=duration_minutes,
            tasks_completed=summary.tasks_completed,
            files_modified=summary.files_modified
        )

        return summary

    def generate_summary(
        self,
        session_data: SessionData,
        memory_stats: MemoryStats,
        task_stats: TaskStats
    ) -> str:
        """
        Generate markdown session summary from triple-source data.

        High-level convenience method that aggregates and generates markdown.

        Args:
            session_data: Session metadata from work_sessions
            memory_stats: Memory statistics from semantic_memory
            task_stats: Task statistics from micro_tasks

        Returns:
            Markdown-formatted session summary

        Raises:
            ValueError: If required data is missing
        """
        try:
            # Aggregate data
            summary = self.aggregate_session_data(
                session_data,
                memory_stats,
                task_stats
            )

            # Generate markdown
            markdown = summary.to_markdown()

            self.logger.info(
                "Session summary generated",
                session_id=session_data.session_id,
                markdown_length=len(markdown)
            )

            return markdown

        except Exception as e:
            self.logger.error(
                "Failed to generate session summary",
                error=str(e),
                error_type=type(e).__name__
            )
            raise

    def validate_summary(self, summary: SessionSummary) -> bool:
        """
        Validate session summary for completeness.

        Checks that summary has all required fields and reasonable values.

        Args:
            summary: SessionSummary to validate

        Returns:
            True if valid, False otherwise
        """
        try:
            # Check required fields
            if not summary.session_id:
                self.logger.warning("Missing session_id")
                return False

            if not summary.started_at or not summary.ended_at:
                self.logger.warning("Missing timestamps")
                return False

            # Check duration is reasonable
            if summary.duration_minutes < 0:
                self.logger.warning(
                    "Negative duration",
                    duration=summary.duration_minutes
                )
                return False

            # Check that end time is after start time
            if summary.ended_at < summary.started_at:
                self.logger.warning("End time before start time")
                return False

            self.logger.debug(
                "Summary validation passed",
                session_id=summary.session_id
            )

            return True

        except Exception as e:
            self.logger.error(
                "Summary validation error",
                error=str(e)
            )
            return False


def format_session_for_storage(summary: SessionSummary) -> Dict[str, Any]:
    """
    Format SessionSummary for storage in semantic_memory.

    Prepares summary data for storage with appropriate content_type
    and keywords for later retrieval.

    Args:
        summary: SessionSummary to format

    Returns:
        Dict with content, content_type, and keywords
    """
    return {
        "content": summary.to_markdown(),
        "content_type": "context",  # Session summaries are contextual information
        "keywords": [
            "session",
            "summary",
            summary.session_id,
            f"{summary.tasks_completed}_tasks",
            f"{summary.files_modified}_files",
            summary.status
        ]
    }


if __name__ == "__main__":
    # Test script
    from datetime import timedelta

    print("DevStream Session Summary Generator Test")
    print("=" * 50)

    # Create test data
    print("\n1. Creating test session data...")
    session_data = SessionData(
        session_id="test-session-001",
        session_name="Phase 3 Implementation",
        started_at=datetime.now() - timedelta(hours=2),
        ended_at=datetime.now(),
        tokens_used=15000,
        active_tasks=["DEVSTREAM-001", "DEVSTREAM-002"],
        completed_tasks=["DEVSTREAM-003"],
        status="completed"
    )
    print(f"   Session: {session_data.session_name}")

    print("\n2. Creating test memory stats...")
    memory_stats = MemoryStats(
        files_modified=5,
        decisions_made=2,
        learnings_captured=3,
        total_records=50,
        file_list=[
            "session_data_extractor.py",
            "session_summary_generator.py",
            "session_end.py"
        ],
        decisions=[
            "Use triple-source architecture for accuracy",
            "Implement Context7 async patterns for performance"
        ],
        learnings=[
            "aiosqlite row_factory enables clean data access",
            "Time-range queries essential for session-scoped data",
            "Graceful degradation critical for production reliability"
        ]
    )
    print(f"   Files modified: {memory_stats.files_modified}")
    print(f"   Decisions: {memory_stats.decisions_made}")

    print("\n3. Creating test task stats...")
    task_stats = TaskStats(
        total_tasks=10,
        completed=7,
        active=2,
        failed=0,
        task_titles=[
            "Implement SessionDataExtractor",
            "Create SessionSummaryGenerator",
            "Integrate WorkSessionManager"
        ]
    )
    print(f"   Completed: {task_stats.completed}/{task_stats.total_tasks}")

    print("\n4. Generating session summary...")
    generator = SessionSummaryGenerator()

    try:
        summary = generator.aggregate_session_data(
            session_data,
            memory_stats,
            task_stats
        )
        print(f"   ✅ Summary aggregated")
        print(f"   Duration: {summary.duration_minutes} minutes")
        print(f"   Tasks: {summary.tasks_completed} completed")

        # Validate
        print("\n5. Validating summary...")
        if generator.validate_summary(summary):
            print("   ✅ Validation passed")
        else:
            print("   ❌ Validation failed")

        # Generate markdown
        print("\n6. Generating markdown...")
        markdown = summary.to_markdown()
        print(f"   ✅ Markdown generated: {len(markdown)} chars")

        # Show preview
        print("\n7. Markdown preview:")
        print("-" * 50)
        print(markdown[:800])  # First 800 chars
        print("...")
        print("-" * 50)

        # Format for storage
        print("\n8. Formatting for storage...")
        storage_data = format_session_for_storage(summary)
        print(f"   Content type: {storage_data['content_type']}")
        print(f"   Keywords: {', '.join(storage_data['keywords'][:5])}")

        print("\n" + "=" * 50)
        print("Test completed successfully!")

    except Exception as e:
        print(f"\n❌ Test failed: {e}")
        import traceback
        traceback.print_exc()